#### 骰子的点数

将一个骰子投掷n次，获得的总点数为s，s的可能范围为n~6n。

掷出某一点数，可能有多种掷法，例如投掷2次，掷出3点，共有[1,2],[2,1]两种掷法。

请求出投掷n次，掷出n~6n点分别有多少种掷法。

#### 样例1

```java
输入：n=1

输出：[1, 1, 1, 1, 1, 1]

解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。
```

#### 样例2

```java
输入：n=2

输出：[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]

解释：投掷2次，可能出现的点数为2-12，共计11种。每种点数可能掷法数目分别为1,2,3,4,5,6,5,4,3,2,1。

      所以输出[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]。
```

<!--more-->



##### 法一：这一题我们使用动态规划，但是一开始并没有想到这个= =，其实这一题有点像找零钱的感觉，比如说两个骰子掷出7，其实可以分为第二个骰子掷出1 - 6，那么前一个骰子就相对的也就有6种掷法。这一题使用二维DP，其中`dp[i][j]代表i个骰子可以掷出总和为j的掷法种数，而状态方程就是dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2]...dp[i-1][j-6]`，初始化时`dp[1][1]....dp[1][6] = 1，因为一个骰子只能由一种掷法 `

```java
public int[] numberOfDice(int n) {
    if (n <= 0) {
        return new int[]{};
    }
    int[][] dp = new int[n + 1][6 * n + 1];
    //dp[i][j]表示i个骰子能够骰出总和为j的骰法
    //dp[1][1]~dp[1][6]都为1，因为一个骰子只能骰一次
    for (int i = 1; i <= 6; i++) {
        dp[1][i] = 1;
    }
    for (int i = 2; i <= n; i++) {
        for (int j = i * 6; j >= i; j--) {
            dp[i][j] = 0;
            for (int k = 6; k >= 1; k--) {
                //首先j必须大于k，因为掷出的点数最小就是1，j-k必须≥i-1，因为前面是骰子数，后面是点数.点数肯定≥骰子数
                if ( j > k && j - k - i + 1 >= 0) {
                    dp[i][j] += dp[i - 1][j - k];
                }
            }
        }
    }
    //这里要注意，我们的dp数组的第二维是从0开始的，而我们的点数只能是从n ~ 6n，所以要把这些去掉
    int[] res = new int[5 * n + 1];
    for (int i = 0; i < 5 * n + 1; i++) {
        res[i] = dp[n][i + n];
    }
    return res;
}
```

##### 法二：按照我们的经验发现，二维DP通常能转换为一维DP，这一题也是如此，我们细心观察发现，`dp[i][j]只与上一次状态有关dp[i-1]...`所以我们可以将空间减低到一维。

```java
public int[] numberOfDice(int n) {
    if (n <= 0) {
        return new int[]{};
    }
    int[] dp = new int[6 * n + 1];
    //dp[i][j]表示i个骰子能够骰出总和为j的骰法
    //dp[1][1]~dp[1][6]都为1，因为一个骰子只能骰一次
    for (int i = 1; i <= 6; i++) {
        dp[i] = 1;
    }
    for (int i = 2; i <= n; i++) {
        for (int j = i * 6; j >= i; j--) {
            dp[j] = 0;
            for (int k = 6; k >= 1; k--) {
                if ( j > k && j - k - i + 1 >= 0) {
                    dp[j] += dp[j - k];
                }
            }
        }
    }
    int[] res = new int[5 * n + 1];
    for (int i = 0; i < 5 * n + 1; i++) {
        res[i] = dp[i + n];
    }
    return res;
}
```

